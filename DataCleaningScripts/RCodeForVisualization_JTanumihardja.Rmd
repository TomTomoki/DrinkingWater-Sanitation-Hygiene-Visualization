---
title: "IE6600 Team Project"
author: "Jessica Tanumihardja (Team Shabu Shabu)"
due date: "Due: April 10th, 2023 "
output:
  pdf_document: default
  html_notebook: default
---

Dataset: WHO/UNICEF Joint Monitoring Programme for Water Supply, Sanitation and Hygiene (JMP) has reported country, regional and global estimates of progress on drinking water, sanitation and hygiene (WASH) since 1990 https://washdata.org/data/downloads#WLD

```{r setup, include=FALSE}
# echo=T to show the code, eval=T to show the results ----
knitr::opts_chunk$set(echo = T, eval=T) 
# Pre-load packages ----
library(tidyverse) 
library(ggplot2)
library(datasets)
library(haven)
library(readxl)
# library(forecast)
# library(tsbox)
# library(vars)
# library(ggfortify)
#library(caret)


```

# Import the dataset

Use the original dataset downloaded from website: https://washdata.org/data/downloads#WLD 

```{r}
#use the original dataset downloaded from the website
file_path <- "C:/Users/jtanu/Documents/Northeastern/2023SPRING/IE6600/Assignment/FinalProject/JMP_2021_WLD.xlsx"

```

----------------------------------------------------------------------
## Water (TBD)

```{r, cache=TRUE}
water_raw <- read_excel(file_path, sheet = "Water")
```

```{r , cache=TRUE}
water <- read_excel(file_path, sheet = "Water", skip =2)
```

### Rename columns

```{r}
column_names_water <- c(
  "COUNTRY",
  "ISO3",
  "YEAR",
  "POPULATION(THOUSANDS)",
  "%URBAN",
  "NATIONAL_AtLeastBasic",
  "NATIONAL_Limited(>30min)",
  "NATIONAL_Unimproved",
  "NATIONAL_SurfaceWater",
  "NATIONAL_AnnualRateOfChangeInBasic",
  "RURAL_AtLeastBasic",
  "RURAL_Limited(>30min)",
  "RURAL_Unimproved",
  "RURAL_SurfaceWater",
  "RURAL_AnnualRateOfChangeInBasic",
  "URBAN_AtLeastBasic",
  "URBAN_Limited(>30min)",
  "URBAN_Unimproved",
  "URBAN_SurfaceWater",
  "URBAN_AnnualRateOfChangeInBasic",
  "NATIONAL_SafelyManaged_SafelyManaged",
  "NATIONAL_SafelyManaged_AccessibleOnPremises",
  "NATIONAL_SafelyManaged_AvailableWhenNeeded",
  "NATIONAL_SafelyManaged_FreeFromContamination",
  "NATIONAL_SafelyManaged_AnnualRateOfChangeInSafelyManaged",
  "NATIONAL_FacilityType_Piped",
  "NATIONAL_FacilityType_NonPiped",
  "RURAL_SafelyManaged_SafelyManaged",
  "RURAL_SafelyManaged_AccessibleOnPremises",
  "RURAL_SafelyManaged_AvailableWhenNeeded",
  "RURAL_SafelyManaged_FreeFromContamination",
  "RURAL_SafelyManaged_AnnualRateOfChangeInSafelyManaged",
  "RURAL_FacilityType_Piped",
  "RURAL_FacilityType_NonPiped",
  "URBAN_SafelyManaged_SafelyManaged",
  "URBAN_SafelyManaged_AccessibleOnPremises",
  "URBAN_SafelyManaged_AvailableWhenNeeded",
  "URBAN_SafelyManaged_FreeFromContamination",
  "URBAN_SafelyManaged_AnnualRateOfChangeInSafelyManaged",
  "URBAN_FacilityType_Piped",
  "URBAN_FacilityType_NonPiped",
  "SI",
  "SDGRegion", 
  "WHORegion", 
  "UNICEFProgrammingRegion", 
  "UNICEFReportingRegion"
)

water <- water %>% rename_with(~column_names_water)
names(water)
#sapply(water, class)
```

### Tidying data

```{r}
#tidying
water <- water %>% select(-SI) #remove indexing

#replace "-" with NA
water <- water %>% 
  mutate_all(~ifelse(. == "-", NA, .)) 

#head(water)
```

### Set as numeric

```{r eval=FALSE}
#check index to change to numeric (6:41)
names(water)
```


```{r}
#clean non numeric
#remove < and > on numbers column index 6 to 17
  #which one is better? Do this or set <1 as 0.5? 
#hygiene_data[, 6:17] <- lapply(hygiene_data[, 6:17], function(x)
#  as.numeric(gsub("\\>|<","", as.character(x)))) #or "[^[:alnum:]]" or "[^[0-9]]" 

# For now, "<1" is replaced with 0.5, and ">99" is replaced with 99.5
water <- water %>% 
  mutate_all(~ifelse(. == "<1", 0.5, .)) 

water <- water %>% 
  mutate_all(~ifelse(. == ">99", 99.5, .))

#set as numeric
water <- water %>%
  mutate_at(6:41, as.numeric)

sapply(water, class)
```


### Divide to two df & Pivot Longer

Col 6:20 are one type of df, Col 21:41 are details of those df. So will separate into two df.

```{r}
### split into two df and pivot longer

#water overview
water1 <- water %>%
  select(c(1:5, 6:20, 42:45)) %>%
  pivot_longer(
    cols = NATIONAL_AtLeastBasic:URBAN_AnnualRateOfChangeInBasic,
    names_to = c("REGION", "ServiceLevel"),
    names_sep = "_",
    values_to = "Percentage")

#water details: Safely Managed Criteria and Facility Type
water2 <- water %>%
  select(c(1:5, 21:41, 42:45)) %>%
  pivot_longer(
    cols =  NATIONAL_SafelyManaged_SafelyManaged:URBAN_FacilityType_NonPiped,
    names_to = c("REGION", "SafelyManagedCriteria", "CriteriaDetails"),
    names_sep = "_",
    values_to = "Percentage")
```

```{r eval=FALSE}
names(water1)
```

```{r eval=FALSE}
names(water2)
```

Save df for future use
```{r eval=FALSE}
#if want to write the df in folder
#write.csv(water1, "C:/Users/jtanu/Documents/Northeastern/2023SPRING/IE6600/Assignment/FinalProject/water1.csv", row.names=FALSE)

#write.csv(water2, "C:/Users/jtanu/Documents/Northeastern/2023SPRING/IE6600/Assignment/FinalProject/water2.csv", row.names=FALSE)
```

### Load files directly

```{r}
df_water <- read_csv("C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/water1.csv")

df_water2 <- read_csv("C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/water2.csv")
```

```{r eval=FALSE}
#check columns
sapply(df_water2, class)
```


### Donut Plot - water

World summary:

```{r}
unique(water1$ServiceLevel)
```

```{r}
#set hole size to be the x axis so we can control the shape
hsize <- 3

df_water %>% 
  filter(ServiceLevel != "AnnualRateOfChangeInBasic" & 
           YEAR == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(ServiceLevel) %>% #combine all country
  summarise(median = median(Percentage)) %>% 
  ggplot(aes(x=hsize, y=median))+
    geom_col(aes(fill=ServiceLevel))+
    geom_text(aes(label = paste(round(median,2), " %")), #reduce decimal on value
            position = position_dodge(1)) +
    coord_polar(theta = "y")+ #convert bar chart to polar
      # Set the limits, which is important for adding the hole
    xlim(c(0.2, hsize + 0.5))+ #(c(2018.5, 2020.5)) +
      # Set theme_void() to remove grid lines and everything else from the plot
   scale_fill_brewer(palette = "PuBuGn") + #set color pallete per dataset
    theme_void()
```


```{r eval=FALSE}
df_water %>% 
  filter(ServiceLevel != "AnnualRateOfChangeInBasic" & 
           YEAR == 2020 &
           REGION == "NATIONAL" &
           COUNTRY == "Zimbabwe") #%>% #remove NA to prepare for calculation below
  #group_by(ServiceLevel) %>% #combine all country
  #summarise(median = median(Percentage, na.rm=TRUE)) 
```


```{r}
library(ggiraph)

df_donut <- df_water %>% 
  filter(ServiceLevel != "AnnualRateOfChangeInBasic" & 
           YEAR == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(ServiceLevel) %>% #combine all country
  summarise(median = median(Percentage, na.rm=TRUE)) 

hsize <- 3

plot <- ggplot(df_donut, aes(x=hsize, y=median, fill=ServiceLevel))+
  geom_col_interactive(aes(tooltip = paste(ServiceLevel, ": ", round(median,2), "%")))+
  coord_polar(theta = "y")+ #convert bar chart to polar
  # Set the limits, which is important for adding the hole
  xlim(c(0.2, hsize + 0.5))+
  theme_void() +
  scale_fill_brewer(palette = "PuBuGn") +
  labs(title="world median dw")
  

girafe(ggobj = plot, options = c(opts_hover(css = "cursor:pointer;fill:red;stroke:red;")))
```


**Per country**

source: 

* https://r-graph-gallery.com/128-ring-or-donut-plot.html 
* https://r-charts.com/part-whole/donut-chart-ggplot2/ 
* https://stackoverflow.com/questions/45445904/weird-cumsum-not-working-on-dplyr 

```{r eval=FALSE}
df.plot <- df_water %>% 
  filter(ServiceLevel != "AnnualRateOfChangeInBasic" & 
           YEAR == 2020 &
           REGION == "NATIONAL" &
           COUNTRY == "Zimbabwe") %>%  #%in% c("Indonesia", "Japan", "China") & #facet wrap
           #remove NA to prepare for calculation below
  group_by(ServiceLevel, COUNTRY, YEAR) %>% #combine all country
  summarise(median = median(Percentage, na.rm = TRUE)) %>% 
  ungroup()

#add column to calculate the label position
df.plot <- df.plot %>% 
  arrange(-desc(median)) %>% 
  mutate(ymax = cumsum(median),
         ymin = c(0, head(ymax, n=-1)),
         labelPos = (ymin + ymax)/2#,
         #label = paste0(ServiceLevel, ": \n", round(median,2), "%")
         ) #%>% 

df.plot
```

```{r}
plot_c <- df.plot %>% 
  ggplot(aes(ymax = ymax, ymin = ymin, xmin = 2.5, xmax=4))+ 
    geom_rect(aes(fill=ServiceLevel))+
    #scale_y_reverse()+
    geom_text(x = 4, aes(y = labelPos,
                  label = paste0(ServiceLevel, ": \n", round(median,2), "%")),
                  size = 4)+ #,
                  #color = ServiceLevel)+ #reduce decimal on value
              #position = position_stack(vjust = 0.5))+#,
              #hjust = -0.75) +
    coord_polar(theta = "y")+ #convert bar chart to polar
    
      # Set the limits, which is important for adding the hole
    xlim(c(-1,4))+ #0.2, hsize + 0.5))+ #(c(2018.5, 2020.5)) +
    scale_fill_brewer(palette = "PuBuGn") + #set color pallete per dataset
        # Set theme_void() to remove grid lines and everything else from the plot
    #facet_wrap(~COUNTRY)+
    theme_void()+
    labs(title = "Service Level Distribution Summary",
         subtitle = "Median Percentage of selected Country")+
    theme(legend.position = "none")

plot_c
```


```{r}
#set hole size to be the x axis so we can control the shape
hsize <- 3

# df.plot <- df_water %>% 
#   filter(ServiceLevel != "AnnualRateOfChangeInBasic" & 
#            YEAR == 2020 &
#            REGION == "NATIONAL" &
#            COUNTRY == "Zimbabwe") %>%  #%in% c("Indonesia", "Japan", "China") & #facet wrap
#            #remove NA to prepare for calculation below
#   group_by(ServiceLevel, COUNTRY, YEAR) %>% #combine all country
#   summarise(median = median(Percentage, na.rm = TRUE)) %>%
#   ungroup() %>% 
#   mutate(cumsum = cumsum(median))
#add cummulative here for label

plot_c <- df.plot %>% 
  ggplot()+ 
    geom_col(aes(x=hsize, y=median, fill=ServiceLevel))+
    #scale_y_reverse()+
    geom_text(aes(x = hsize, y = labelPos, 
                  label = paste(round(median,2), "%")))+ #reduce decimal on value
              #position = position_stack(vjust = 0.5))+#,
              #hjust = -0.75) +
    coord_polar(theta = "y")+ #convert bar chart to polar
    
      # Set the limits, which is important for adding the hole
    xlim(c(0.2, hsize + 0.5))+ #(c(2018.5, 2020.5)) +
    scale_fill_brewer(palette = "PuBuGn") + #set color pallete per dataset
        # Set theme_void() to remove grid lines and everything else from the plot
    #facet_wrap(~COUNTRY)+
    #theme_void()+
    labs(title = "Service Level Distribution Summary",
         subtitle = "Median Percentage of selected Country")

plot_c
```

```{r}
water1 %>% 
    group_by(ServiceLevel, COUNTRY) %>% #combine all country/selected 
    summarise(median = median(Percentage)) 
```


```{r}

plot_donut <- function(df){
  df.donut <- df %>% 
    group_by(ServiceLevel, COUNTRY, YEAR) %>% #combine all country/selected 
    summarise(median = median(Percentage)) 
}
```


**Per WHO Region**

```{r}
#set hole size to be the x axis so we can control the shape
hsize <- 3

water1 %>% 
  filter(ServiceLevel != "AnnualRateOfChangeInBasic" & 
           YEAR == 2020 & #how to deal with range?
           REGION == "NATIONAL" &
           WHORegion == "South-East Asia" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(ServiceLevel) %>% #combine all country
  summarise(median = median(Percentage)) %>% 
  ggplot(aes(x=hsize, y=median))+
    geom_col(aes(fill=ServiceLevel))+
    geom_text(aes(label = paste(round(median,2), "%")), #reduce decimal on value
            position = position_dodge(1)) +
    coord_polar(theta = "y")+ #convert bar chart to polar
      # Set the limits, which is important for adding the hole
    xlim(c(0.2, hsize + 0.5))+ #(c(2018.5, 2020.5)) +
    scale_fill_brewer(palette = "PuBuGn") + #set color pallete per dataset
        # Set theme_void() to remove grid lines and everything else from the plot
    theme_void()
```

### Lollipop for diverging and ranking

Diverging deviation for Annual Rate of Change in Basic:

```{r}
#per country
water1 %>% 
  filter(ServiceLevel == "AnnualRateOfChangeInBasic" &  
           YEAR == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  arrange(desc(Percentage)) %>% #highest first 
  head(20) %>% 
  ggplot(aes(x=COUNTRY, y=Percentage))+
    geom_segment(aes(xend=COUNTRY, yend=0)) +
    geom_point(size=6, color="lightblue") +
    geom_text(aes(label=round(Percentage,1)), color="black", size=3)+
    theme_bw() +
    labs(x="", y="median AnnualRateOfChangeInBasic %",
         title="Top 20 Countries")+
    coord_flip()
```

```{r}
#per country
water1 %>% 
  filter(ServiceLevel == "AnnualRateOfChangeInBasic" & 
           YEAR == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  arrange(desc(Percentage)) %>% #highest first 
  tail(10) %>% 
  ggplot(aes(x=COUNTRY, y=Percentage))+
    geom_segment(aes(xend=COUNTRY, yend=0)) +
    geom_point(size=6, color="lightblue") +
    geom_text(aes(label=round(Percentage,2)), color="black", size=3)+
    theme_bw() +
    labs(x="", y="median AnnualRateOfChangeInBasic %",
         title="Bottom 10 countries")+
    coord_flip()
```

## Summary Chart

```{r}
unique(water1$ServiceLevel)
```


```{r}
#create summary df for the whole world "At Least Basic" level
  #can also do it for "AnnualRateOfChangeInBasic" for ALL dataset?
water_summary <- water1 %>% 
  filter(ServiceLevel == "AtLeastBasic" &
           REGION == "NATIONAL") %>% #can delete this if wanted to show difference
  group_by(YEAR, ServiceLevel) %>% #combine all country
  summarise(median = median(Percentage, na.rm=TRUE))

sanitation_summary <- sanitation1 %>% 
  filter(ServiceLevel == "AtLeastBasic" &
           REGION == "NATIONAL") %>% 
  group_by(YEAR, ServiceLevel) %>% #combine all country
  summarise(median = median(Percentage, na.rm=TRUE))

hygiene_summary <- hygiene1 %>% 
  filter(ServiceLevel == "Basic" &
           REGION == "NATIONAL") %>% 
  group_by(YEAR, ServiceLevel) %>% #combine all country
  summarise(median = median(Percentage, na.rm=TRUE))
```

source: https://www.statology.org/merge-multiple-data-frames-in-r/

```{r}
#merge those datasets (put to list and merge all)
df_summary <- list(water_summary, sanitation_summary, hygiene_summary)

df_summary <- df_summary %>% reduce(full_join, by='YEAR')
```

Drop not useful columns and rename colnames

```{r}
df_summary <- df_summary %>% 
  select(YEAR, ServiceLevel.x, median.x, median.y, median)

names(df_summary) <- c("YEAR", "ServiceLevel", "Water", "Sanitation", "Hygiene")
df_summary
```

```{r}
#pivot longer
df_summary <- df_summary %>% 
  pivot_longer(
    cols = Water:Hygiene,
    names_to = "Dataset",
    values_to = "MedianPercentage")
```

Write `df_summary` in CSV for ease of data pulling:
```{r eval=FALSE}
#write.csv(df_summary, "C:/Users/jtanu/Documents/Northeastern/2023SPRING/IE6600/Assignment/FinalProject/df_summary.csv", row.names=FALSE)
```

**ALL YEAR in range COMPARISON**

Should we show sum of population or percentage?

```{r}
#plot summary
df_summary %>% 
  filter(YEAR >= 2010 & YEAR <= 2020) %>% 
  ggplot(aes(x=YEAR, y=MedianPercentage)) + 
    geom_col(aes(fill=Dataset), position = "dodge") + 
    theme_bw() +
    scale_fill_brewer(palette = "Set2")+
    labs(title = "World Percentage of At Least Basic", 
         subtitle = "Median of All Countries Coverage Percentage",
         y = "Coverage Percentage")
```
**Two year 3 dataset comparison**

Can also add REGION difference in FACET_WRAP() if wanted

```{r}
#plot summary
df_summary %>% 
  filter(YEAR == 2000 | YEAR == 2020) %>% #can make this reactive
  mutate(YEAR = factor(YEAR)) %>% 
  ggplot(aes(x=YEAR, y=MedianPercentage)) + 
    geom_col(aes(fill=Dataset), position = "dodge", width=0.5) +
    theme_bw() +
    scale_fill_brewer(palette = "Set2")+
    labs(title = "Growth of World's 'At Least Basic' Service Level", 
         subtitle = "Median of All Countries Percentage",
         y = "Percentage (median)")
```

color palette: https://r-graph-gallery.com/38-rcolorbrewers-palettes.html

**Population Lacking of Basic Sanitation**

```{r}
#sanitation summary (can also make for water and hygiene)
sanitation1 %>% 
  filter(ServiceLevel %in% c("Limited(shared)", "Unimproved", "OpenDefecation") & 
           REGION == "NATIONAL") %>% 
  filter(YEAR == 2000 | YEAR == 2020) %>% 
  group_by(YEAR, ServiceLevel) %>% #combine all country
  summarise(popul = sum(Percentage/100 * `POPULATION(THOUSANDS)` /1000, #sum of all countries
                           na.rm=TRUE)) %>% #remove NA to maximize sample
  mutate(YEAR = factor(YEAR)) %>% 
  ggplot(aes(x=YEAR, y=popul))+
    geom_col(aes(fill=ServiceLevel), width = 0.5)+
    scale_fill_brewer(palette = "GnBu") + #set color pallete per dataset
    theme_bw()+
  labs(title="World Population Lacking of Basic Sanitation",
       subtitle = "REGION = NATIONAL",
       y = "Population (millions)")
```


---------------------------------------------------------------------------------


## SANITATION - PIVOT LONGER

```{r reload, cache=TRUE}
#load raw dataset to check
sanitation_raw <- read_excel(file_path, sheet = "Sanitation")

#head(sanitation)
```

```{r}
names(sanitation_raw)
```
### Rename Columns

```{r}
sanitation <- read_excel(file_path, sheet = "Sanitation",
                         skip = 2)

column_names <- c(
  "COUNTRY",
  "ISO3",
  "YEAR",
  "POPULATION(THOUSANDS)",
  "%URBAN",
  "NATIONAL_AtLeastBasic",
  "NATIONAL_Limited(shared)",
  "NATIONAL_Unimproved",
  "NATIONAL_OpenDefecation",
  "NATIONAL_AnnualRateOfChangeInBasic",
  "NATIONAL_AnnualRateOfChangeInOpenDefecation",
  "RURAL_AtLeastBasic",
  "RURAL_Limited(shared)",
  "RURAL_Unimproved",
  "RURAL_OpenDefecation",
  "RURAL_AnnualRateOfChangeInBasic",
  "RURAL_AnnualRateOfChangeInOpenDefecation",
  "URBAN_AtLeastBasic",
  "URBAN_Limited(shared)",
  "URBAN_Unimproved",
  "URBAN_OpenDefecation",
  "URBAN_AnnualRateOfChangeInBasic",
  "URBAN_AnnualRateOfChangeInOpenDefecation",
  "NATIONAL_SafelyManaged_Total",
  "NATIONAL_SafelyManaged_DisposedInSitu",
  "NATIONAL_SafelyManaged_EmptiedAndTreated",
  "NATIONAL_SafelyManaged_WastewaterTreated",
  "NATIONAL_SafelyManaged_TotalAnnualRateOfChange",
  "NATIONAL_FacilityType_LatrinesAndOthers",
  "NATIONAL_FacilityType_SepticTanks",
  "NATIONAL_FacilityType_SewerConnections",
  "RURAL_SafelyManaged_Total",
  "RURAL_SafelyManaged_DisposedInSitu",
  "RURAL_SafelyManaged_EmptiedAndTreated",
  "RURAL_SafelyManaged_WastewaterTreated",
  "RURAL_SafelyManaged_TotalAnnualRateOfChange",
  "RURAL_FacilityType_LatrinesAndOthers",
  "RURAL_FacilityType_SepticTanks",
  "RURAL_FacilityType_SewerConnections",
  "URBAN_SafelyManaged_Total",
  "URBAN_SafelyManaged_DisposedInSitu",
  "URBAN_SafelyManaged_EmptiedAndTreated",
  "URBAN_SafelyManaged_WastewaterTreated",
  "URBAN_SafelyManaged_TotalAnnualRateOfChange",
  "URBAN_FacilityType_LatrinesAndOthers",
  "URBAN_FacilityType_SepticTanks",
  "URBAN_FacilityType_SewerConnections",
  "SI",
  "SDGRegion", 
  "WHORegion", 
  "UNICEFProgrammingRegion", 
  "UNICEFReportingRegion"
)

sanitation <- sanitation %>% rename_with(~column_names)

sapply(sanitation, class)
```


### Tidying data

```{r}
#tidying
sanitation <- sanitation %>% select(-SI) #remove indexing

#replace "-" with NA
sanitation <- sanitation %>% 
  mutate_all(~ifelse(. == "-", NA, .)) 

head(sanitation)
```

### Set as numeric

```{r}
#clean non numeric
#remove < and > on numbers column index 6 to 17
  #which one is better? Do this or set <1 as 0.5? 
#hygiene_data[, 6:17] <- lapply(hygiene_data[, 6:17], function(x)
#  as.numeric(gsub("\\>|<","", as.character(x)))) #or "[^[:alnum:]]" or "[^[0-9]]" 

# For now, "<1" is replaced with 0.5, and ">99" is replaced with 99.5
sanitation <- sanitation %>% 
  mutate_all(~ifelse(. == "<1", 0.5, .))

sanitation <- sanitation %>% 
  mutate_all(~ifelse(. == ">99", 99.5, .))

#set as numeric
sanitation <- sanitation %>%
  mutate_at(6:47, as.numeric)

sapply(sanitation, class)
```


### Divide to two df & Pivot Longer

Col 6:23 are one type of df, Col 24:47 are details of those df. So will separate into two df.

```{r}
### split into two df and pivot longer

#sanitation overview
sanitation1 <- sanitation %>%
  select(c(1:5, 6:23, 48:51)) %>%
  pivot_longer(
    cols = NATIONAL_AtLeastBasic:URBAN_AnnualRateOfChangeInOpenDefecation,
    names_to = c("REGION", "ServiceLevel"),
    names_sep = "_",
    values_to = "Percentage")

#sanitation details: Safely Managed Criteria and Facility Type
sanitation2 <- sanitation %>%
  select(c(1:5, 24:47, 48:51)) %>%
  pivot_longer(
    cols =  NATIONAL_SafelyManaged_Total:URBAN_FacilityType_SewerConnections,
    names_to = c("REGION", "ImprovedSanitationCriteria", "CriteriaDetails"),
    names_sep = "_",
    values_to = "Percentage")
```

```{r eval=FALSE}
names(sanitation1)
```
```{r eval=FALSE}
names(sanitation2)
```

```{r}
#check ServiceLevels
unique(sanitation1$ServiceLevel)
```

```{r}
#check ServiceLevels
unique(sanitation2$CriteriaDetails)
```

Save df for future use (github)

```{r eval=FALSE}
#edit the sanitation 2 old file
#if want to write the df in folder
write.csv(sanitation1, "C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/sanitation1.csv", row.names=FALSE)

write.csv(sanitation2, "C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/sanitation2.csv", row.names=FALSE)
```

### Load files directly

```{r}
sanitation1 <- read_csv("C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/sanitation1.csv")

sanitation2 <- read_csv("C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/sanitation2.csv")
```

```{r}
sanitation2 %>% filter()
```



### QUESTION

How to pivot longer? Since it has two different type of data here. We have:

* `cols = NATIONAL_AtLeastBasic:URBAN_AnnualRateOfChangeInOpenDefecation` are called "Service Level" percentage
* `cols = NATIONAL_Exc-SafelyManaged:URBAN_Inc-SewerConnections` are called "Facility Type"

Split it into two df? 

### Donut Plot - Sanitation

World summary:

```{r}
unique(sanitation1$ServiceLevel)
```

```{r}
#set hole size to be the x axis so we can control the shape
hsize <- 3

sanitation1 %>% 
  filter(ServiceLevel != "AnnualRateOfChangeInBasic" & 
           ServiceLevel != "AnnualRateOfChangeInOpenDefecation" &
           YEAR == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(ServiceLevel) %>% #combine all country
  summarise(median = median(Percentage)) %>% 
  ggplot(aes(x=hsize, y=median))+
    geom_col(aes(fill=ServiceLevel))+
    geom_text(aes(label = paste(round(median,2), " %")), #reduce decimal on value
            position = position_dodge(1)) +
    coord_polar(theta = "y")+ #convert bar chart to polar
      # Set the limits, which is important for adding the hole
    xlim(c(0.2, hsize + 0.5))+ #(c(2018.5, 2020.5)) +
      # Set theme_void() to remove grid lines and everything else from the plot
    scale_fill_brewer(palette = "GnBu") + #set color pallete per dataset
    theme_void()
```

**Per country**

```{r}
#set hole size to be the x axis so we can control the shape
hsize <- 3

sanitation1 %>% 
  filter(ServiceLevel != "AnnualRateOfChangeInBasic" & 
           ServiceLevel != "AnnualRateOfChangeInOpenDefecation" & 
           YEAR == 2020 &
           REGION == "NATIONAL" &
           COUNTRY == "Indonesia" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(ServiceLevel) %>% #combine all country
  summarise(median = median(Percentage)) %>% 
  ggplot(aes(x=hsize, y=median))+
    geom_col(aes(fill=ServiceLevel))+
    geom_text(aes(label = paste(round(median,2), "%")), #reduce decimal on value
            position = position_dodge(1)) +
    coord_polar(theta = "y")+ #convert bar chart to polar
      # Set the limits, which is important for adding the hole
    xlim(c(0.2, hsize + 0.5))+ #(c(2018.5, 2020.5)) +
    scale_fill_brewer(palette = "GnBu") + #set color pallete per dataset
        # Set theme_void() to remove grid lines and everything else from the plot
    theme_void()
```

**Per WHO Region**

```{r}
#set hole size to be the x axis so we can control the shape
hsize <- 3

sanitation1 %>% 
  filter(ServiceLevel != "AnnualRateOfChangeInBasic" & 
           ServiceLevel != "AnnualRateOfChangeInOpenDefecation" & 
           YEAR == 2020 &
           REGION == "NATIONAL" &
           WHORegion == "South-East Asia" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(ServiceLevel) %>% #combine all country
  summarise(median = median(Percentage)) %>% 
  ggplot(aes(x=hsize, y=median))+
    geom_col(aes(fill=ServiceLevel))+
    geom_text(aes(label = paste(round(median,2), "%")), #reduce decimal on value
            position = position_dodge(1)) +
    coord_polar(theta = "y")+ #convert bar chart to polar
      # Set the limits, which is important for adding the hole
    xlim(c(0.2, hsize + 0.5))+ #(c(2018.5, 2020.5)) +
    scale_fill_brewer(palette = "GnBu") + #set color pallete per dataset
        # Set theme_void() to remove grid lines and everything else from the plot
    theme_void()
```

### Lollipop for diverging and ranking

Diverging deviation for Annual Rate of Change in Basic:

```{r}
#per country
sanitation1 %>% 
  filter(ServiceLevel == "AnnualRateOfChangeInBasic" &  
           YEAR == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  arrange(desc(Percentage)) %>% #highest first 
  head(20) %>% 
  ggplot(aes(x=COUNTRY, y=Percentage))+
    geom_segment(aes(xend=COUNTRY, yend=0)) +
    geom_point(size=6, color="chocolate1") +
    geom_text(aes(label=round(Percentage,1)), color="black", size=3)+
    theme_bw() +
    labs(x="", y="median AnnualRateOfChangeInBasic %",
         title="Top 20 Countries")+
    coord_flip()
```

```{r}
#per country
sanitation1 %>% 
  filter(ServiceLevel == "AnnualRateOfChangeInBasic" & 
           YEAR == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  arrange(desc(Percentage)) %>% #highest first 
  tail(10) %>% 
  ggplot(aes(x=COUNTRY, y=Percentage))+
    geom_segment(aes(xend=COUNTRY, yend=0)) +
    geom_point(size=6, color="chocolate1") +
    geom_text(aes(label=round(Percentage,2)), color="black", size=3)+
    theme_bw() +
    labs(x="", y="median AnnualRateOfChangeInBasic %",
         title="Bottom 10 countries")+
    coord_flip()
```



---------------------------------------------------------------------------------
## HYGIENE

Definition:
Hygiene refers to the conditions and practices that help maintain health and prevent spread of disease including handwashing, food hygiene, and menstrual hygiene management (https://washdata.org/monitoring/hygiene).

```{r eval=FALSE}
hygiene_raw <- read_excel(file_path, sheet = "Hygiene") #.name_repair = "universal")

hygiene_raw
```

### Rename columns

```{r}
#rename column names
hygiene <- read_excel(file_path, sheet = "Hygiene")

#tidying
hygiene <- hygiene[-c(1),] #remove 2nd row (1st row in R)

column_names_hygiene <- c(
  "COUNTRY",
  "ISO3",
  "YEAR",
  "POPULATION(THOUSANDS)",
  "%URBAN",
  "NATIONAL_AtLeastBasic",
  "NATIONAL_Limited(withoutWaterOrSoap)",
  "NATIONAL_NoFacility",
  "NATIONAL_AnnualRateOfChangeInBasic",
  "RURAL_AtLeastBasic",
  "RURAL_Limited(withoutWaterOrSoap)",
  "RURAL_NoFacility",
  "RURAL_AnnualRateOfChangeInBasic",
  "URBAN_AtLeastBasic",
  "URBAN_Limited(withoutWaterOrSoap)",
  "URBAN_NoFacility",
  "URBAN_AnnualRateOfChangeInBasic",
  "SI",
  "SDGRegion", 
  "WHORegion", 
  "UNICEFProgrammingRegion", 
  "UNICEFReportingRegion"
)

hygiene <- hygiene %>% rename_with(~column_names_hygiene)

sapply(hygiene, class)
```




###Tidying Data

```{r}
hygiene <- hygiene %>% dplyr::select(-SI) #remove indexing

#replace "-" with NA
hygiene <- hygiene %>% mutate_all(~ifelse(. == "-", NA, .))

#head(hygiene)
```

### Set as numeric

```{r }
#clean non numeric
# For now, "<1" is replaced with 0.5, and ">99" is replaced with 99.5
hygiene <- hygiene %>% mutate_all(~ifelse(. == "<1", 0.5, .))
hygiene <- hygiene %>% mutate_all(~ifelse(. == ">99", 99.5, .))

hygiene <- hygiene %>%
  mutate_at(6:17, as.numeric)

sapply(hygiene, class)
```

### Pivot Longer 

```{r}
#Make dataset from wide to long, see R documentation (example shown below)
hygiene1 <- hygiene %>% 
  pivot_longer(
    cols = NATIONAL_AtLeastBasic:URBAN_AnnualRateOfChangeInBasic,
    names_to = c("REGION", "ServiceLevel"),
    names_sep = "_",
    values_to = "Percentage")

head(hygiene1)
```

write to df:

```{r}
#if want to write the df in folder
write.csv(hygiene1, "C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/hygiene1.csv", row.names=FALSE)
```

### Load files directly

```{r}
df_hygiene <- read_csv("C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/hygiene1.csv")
```

#### WHO example

```{r eval=FALSE}
#from R documentation example:

#call dplyr dataset
who
```

```{r eval=False}
#check documentation example 

# Multiple variables stored in column names
who %>% pivot_longer(
  cols = new_sp_m014:newrel_f65,
  names_to = c("diagnosis", "gender", "age"),
  names_pattern = "new_?(.*)_(.)(.*)",
  values_to = "count"
)
```


### Preliminary Visualization

```{r}
hygiene_data2 %>% 
  filter(Area == "NATIONAL" & 
           COUNTRY == "Indonesia" &
           FacilityType =="Basic") %>% 
  ggplot(aes(x=Year, y=Percentage))+
    geom_col(aes(fill=Year)) + #aes(color=FacilityType))+
    theme_bw()
```

```{r}
#try bar chart for east & southern asia
hygiene_data2 %>% 
  filter(Area == "URBAN" & 
           SDGRegion == "Eastern and South-Eastern Asia" &
           FacilityType =="Basic") %>% 
  ggplot(aes(x=COUNTRY, y=Percentage))+
    geom_col(aes(fill=Year))+ #it aggregate the year, so need to filter per year
    theme_bw() +
    theme(axis.text.x = element_text(angle=45, hjust=1))
```

```{r}
unique(hygiene_data2$FacilityType)
```


```{r}
hygiene_data2 %>% 
  filter(FacilityType != "AnnualRateOfChangeInBasic" & 
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(FacilityType, Year) %>% 
  summarise(mean = mean(Percentage)) %>% #sum=sum(Percentage*Population.thousands)
  ggplot(aes(x=Year, y=mean))+
    geom_col(aes(fill=FacilityType), position = "dodge")+
    labs(y="World population lacking basic sanitation") +
    theme_bw() #+
    #theme(axis.text.x = element_text(angle=30, hjust=1))
```

### Donut Plot - Hygiene

World summary:

```{r}
#set hole size to be the x axis so we can control the shape
hsize <- 3

hygiene_data2 %>% 
  filter(FacilityType != "AnnualRateOfChangeInBasic" & 
           Year == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(FacilityType) %>% #combine all country
  summarise(median = median(Percentage)) %>% 
  ggplot(aes(x=hsize, y=median))+
    geom_col(aes(fill=FacilityType))+
    geom_text(aes(label = paste(round(median,2), " %")), #reduce decimal on value
            position = position_dodge(1)) +
    coord_polar(theta = "y")+ #convert bar chart to polar
      # Set the limits, which is important for adding the hole
    xlim(c(0.2, hsize + 0.5))+ #(c(2018.5, 2020.5)) +
      # Set theme_void() to remove grid lines and everything else from the plot
    #scale_fill_brewer(palette = "GnBu") + #set color pallete per dataset
    theme_void() #+
    #theme(title="median World population % lacking basic sanitation")
    #labs(y="median World population % lacking basic sanitation") #+
```

Donut chart limit:
    If xlim left boundary is big, no empty circle. You get a pie chart
    If xlim is low, the ring becomes thinner.
    
Source: https://r-charts.com/part-whole/donut-chart-ggplot2/ 
https://r-graph-gallery.com/128-ring-or-donut-plot.html 

```{r}
hygiene_data2 %>% 
  filter(FacilityType != "AnnualRateOfChangeInBasic" & 
           Year == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage))
```

**Per country**

```{r}
#set hole size to be the x axis so we can control the shape
hsize <- 3

hygiene_data2 %>% 
  filter(FacilityType != "AnnualRateOfChangeInBasic" & 
           Year == 2020 &
           REGION == "NATIONAL" &
           COUNTRY == "Indonesia" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(FacilityType) %>% #combine all country
  summarise(median = median(Percentage)) %>% 
  ggplot(aes(x=hsize, y=median))+
    geom_col(aes(fill=FacilityType))+
    geom_text(aes(label = paste(round(median,2), "%")), #reduce decimal on value
            position = position_dodge(1)) +
    coord_polar(theta = "y")+ #convert bar chart to polar
      # Set the limits, which is important for adding the hole
    xlim(c(0.2, hsize + 0.5))+ #(c(2018.5, 2020.5)) +
    #scale_fill_brewer(palette = "GnBu") + #set color pallete per dataset
        # Set theme_void() to remove grid lines and everything else from the plot
    theme_void()
```

**Per Region**

```{r}
#set hole size to be the x axis so we can control the shape
hsize <- 3

hygiene_data2 %>% 
  filter(FacilityType != "AnnualRateOfChangeInBasic" & 
           Year == 2020 &
           REGION == "NATIONAL" &
           WHORegion == "South-East Asia" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(FacilityType) %>% #combine all country
  summarise(median = median(Percentage)) %>% 
  ggplot(aes(x=hsize, y=median))+
    geom_col(aes(fill=FacilityType))+
    geom_text(aes(label = paste(round(median,2), "%")), #reduce decimal on value
            position = position_dodge(1)) +
    coord_polar(theta = "y")+ #convert bar chart to polar
      # Set the limits, which is important for adding the hole
    xlim(c(0.2, hsize + 0.5))+ #(c(2018.5, 2020.5)) +
    #scale_fill_brewer(palette = "GnBu") + #set color pallete per dataset
        # Set theme_void() to remove grid lines and everything else from the plot
    theme_void()
```


### Lollipop for rate of change or ranking - Hygiene

Diverging deviation for Annual Rate of Change in Basic:

```{r}
#per country
hygiene_data2 %>% 
  filter(FacilityType == "AnnualRateOfChangeInBasic" & 
           Year == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  arrange(desc(Percentage)) %>% #highest first 
  head(20) %>% 
  ggplot(aes(x=COUNTRY, y=Percentage))+
    geom_segment(aes(xend=COUNTRY, yend=0)) +
    geom_point(size=6, color="lightgreen") +
    geom_text(aes(label=round(Percentage,1)), color="black", size=3)+
    theme_bw() +
    labs(x="", y="median AnnualRateOfChangeInBasic %")+
    coord_flip()
```

```{r}
#per country
hygiene_data2 %>% 
  filter(FacilityType == "AnnualRateOfChangeInBasic" & 
           Year == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  arrange(desc(Percentage)) %>% #highest first 
  tail(10) %>% 
  ggplot(aes(x=COUNTRY, y=Percentage))+
    geom_segment(aes(xend=COUNTRY, yend=0)) +
    geom_point(size=6, color="lightgreen") +
    geom_text(aes(label=round(Percentage,2)), color="black", size=3)+
    theme_bw() +
    labs(x="", y="median AnnualRateOfChangeInBasic %")+
    coord_flip()
```

source: https://r-graph-gallery.com/302-lollipop-chart-with-conditional-color.html 
https://r-graph-gallery.com/267-reorder-a-variable-in-ggplot2.html


Per region

```{r}
hygiene_data2 %>% 
  filter(FacilityType == "AnnualRateOfChangeInBasic" & 
           Year == 2020 &
           REGION == "NATIONAL" &
           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
  group_by(WHORegion) %>% #combine all country
  summarise(median = median(Percentage)) %>% 
  arrange(desc(median)) %>% #highest first 
  ggplot(aes(x=WHORegion, y=median))+
    geom_segment(aes(xend=WHORegion, yend=0)) +
    geom_point(size=4, color="lightgreen") +
    theme_bw() +
    labs(x="", y="median AnnualRateOfChangeInBasic %")+
    coord_flip()
```


**Ranking?? (TBD)**

```{r eval=FALSE}
#hygiene_data2 %>% 
#  filter(FacilityType != "AnnualRateOfChangeInBasic" & 
#           Year == 2020 &
#           REGION == "NATIONAL" &
#           !is.na(Percentage)) %>% #remove NA to prepare for calculation below
#  group_by(FacilityType, Year) %>% #combine all country
#  summarise(median = median(Percentage)) %>% 
#  ggplot(aes(x=hsize, y=median))+
```


#Forecast

## Load Files

```{r}
df_water <- read_csv("C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/water1.csv")

# df_water2 <- read_csv("C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/water2.csv")

df_hygiene <- read_csv("C:/Users/jtanu/Documents/GitHub/DrinkingWater-Sanitation-Hygiene-Visualization/shinyApp/www/datasets/hygiene1.csv")
```




Filter df for timeseries

```{r}
library(tidyverse)

df_forecast <- df_water %>%
    filter(REGION == "NATIONAL" &
             ServiceLevel != "AnnualRateOfChangeInBasic") %>%
    group_by(YEAR, ServiceLevel) %>% #combine all country
    summarise(median = median(Percentage, na.rm = TRUE)) %>% 
    ungroup()
```

```{r}
#if hygiene
df_forecast <- df_hygiene %>%
    filter(REGION == "NATIONAL" &
             ServiceLevel != "AnnualRateOfChangeInBasic") %>%
    group_by(YEAR, ServiceLevel) %>% #combine all country
    summarise(median = median(Percentage, na.rm = TRUE)) %>% 
    ungroup()
```


###At least basic only:

```{r}
#water
df_forecast_basic <- df_hygiene %>% 
    filter(ServiceLevel == "AtLeastBasic" &
             REGION == "URBAN" &
             COUNTRY == "Canada")#%>%  
    # group_by(YEAR) %>% 
    # summarise(median = median(Percentage, na.rm = TRUE)) %>% #insensitive to outlier
    # ungroup()
```

```{r}
#check if all column values for PErcentage is NA?
if (all(is.na(df_forecast_basic[["Percentage"]]))) {
        # print error/ warning message
        print("No data is available. Please select another country.")
        
      } else {  
        print("Plot available")
      }
```

```{r}
!all(is.na(df_forecast_basic[["Percentage"]]))
```


## convert df to ts

source: https://cran.r-project.org/web/packages/tsbox/vignettes/tsbox.html

```{r}
library(tsbox)
forecast_ts <- df_forecast %>% 
  ts_long() %>% 
  ts_ts()
```

```{r}
forecast_ts_basic <- df_forecast_basic %>% 
  ts_long %>% 
  ts_ts()

forecast_ts_basic 
```

## TS decomposition

We will do TS decomposition to see if the ts has any trend and/or seasonality.

source: https://www.simplilearn.com/tutorials/data-science-tutorial/time-series-forecasting-in-r 

```{r}
#create time series decomposition with frequecy = 5 years (there is a sharp change in 5)
tsdata_basic <- ts(forecast_ts_basic, frequency = 5) 
ddata_basic <- decompose(tsdata_basic, "additive") #predicted to be additive (verified)
#plot(ddata_basic, sub="WORLD At least basic Forecast")
```



```{r}
library(ggplot2)
library(ggfortify)

autoplot(ddata_basic)+
  theme_bw()+
  labs(title = "WORLD 'At least basic'",
       subtitle = "Decomposition of Additive Time Series",
       xlab = "Time (freq=5 years)",
       ylab = "values")
```

It is obvious that the data has trend 

## TS Forecasting

Several ways to do it:

* naive (moving average)
* exponential smoothing:
  + Simple (ses(); no trend/difference, no seasonality)
  + Holt's (holt(); trend, no seasonality; can be additive or multiplicative)
  + Holt-winter's (ets() or error-trend-seasonality, for trend and seasonality)
  + Dampened trend (not applicable for us)
* ARIMA

Naive is basically using the previous day value for today's value. Not useful for us

Exponential smoothing is a step better as it the weight of recent values are greater than the older values. Each values/observations will have a weight/smoothing parameter ( α , β and γ ) and the future value is forecasted by exponential summation of weight * values across time. It is also pretty simple method so does not have high computational effort. 

We can also tune the weight to minimize prediction error but it is not done in this project as we are displaying preliminary forecast of various different region. In holt method, it will automatically optimize the α , β and γ parameters by minimizing AIC and BIC values or errors of the training set (see summary forecast below).  

Source: http://uc-r.github.io/ts_exp_smoothing 

### Exponential Smoothing - ETS/holt-winter's (not used)

Use state space model, source: https://towardsdatascience.com/a-guide-to-forecasting-in-r-6b0c9638c261 

```{r}
#Can also Create samples but not enough dataset :(
# training=window(tseries_ts, start = 2000, end = 2015)
# validation=window(tseries_ts, start = 2016)
```

*Use ETS() and let it choose model type automatically*

Auto model means it will choose a type that minimize RMSE, AIC, and BIC

```{r}
#plot(forecast_ts_basic)
```

```{r}
library(forecast)
#library(MLmetrics)

ets_model = ets(forecast_ts_basic, allow.multiplicative.trend = TRUE)
  #allow multiplicative in case they found any multiplicative trend.
summary(ets_model)
```
ETS(A,A,N) means the exponential smoothing model (ETS) has:

* error type "A" = additive (some data is "M" = multiplicative)
* trend type "A" = additive
* season type "N" = none.

As predicted before, the dataset only have additive trend with no seasonality. 

RMSE (root mean squared error) is really low so the trend is quite good. The prediction accuracy (MAPE) is only 0.0012% though?

source: https://www.rdocumentation.org/packages/forecast/versions/8.21/topics/ets 

https://rstudio-pubs-static.s3.amazonaws.com/681477_4af44c0abe0741d8ad5093df109130b5.html 

```{r}
#library(ModelMetrics)
ets_forecast = forecast(ets_model, h=10)
#ets_forecast
#paste("Validation RMSE: ", round(RMSE(validation, ets_forecast$mean),2))
```

RMSE is not too bad considering mean are mainly in thousands.

```{r}
target <- round(ets_forecast$mean[10], 4)
target_label <- "N/A"
if(target >= 100){
  target_label <- "goal achieved!"
} else {
  target_label <- "goal not achieved"
}

autoplot(ets_forecast, predict.size = 1, 
         predict.colour = 'blue', predict.linetype = 'dashed',
         conf.int = TRUE, conf.int.fill = "lightblue")+
  autolayer(fitted(ets_model), series = "Predicted")+
  theme_bw()+
  theme(text=element_text(size=15))+
  expand_limits(y=100)+
  labs(title = "Time Series Forecast - Exponential Smoothing (ETS)",
       subtitle = paste("[World] [NATIONAL] 'At least basic' 2030 forecast =",
                       target, "%, ", target_label),
       x = "YEAR",
       y = "Median Percentage (%)")+
  guides(colour=guide_legend(title=""))+
    theme(legend.position = "bottom", 
          legend.background = element_rect(fill="lightblue",linetype="solid"), 
          plot.subtitle = element_text(color = "darkblue"))
```

### ES - (HOLT) with trend only

Holt is double exponential coefficient using alpha and beta. If those values are closer to 1, that means it is fast learning. If it is closer to 0, then it is slow learning. We are using the model as is so the alpha and beta coefficient is automatically chosen by the model. We can improve this by running an optimizer (loop within certain range of beta). However, since the plot is reactive, we will just leave it as is (auto value). 

Source: https://www.geeksforgeeks.org/exponential-smoothing-in-r-programming/ 

```{r eval=FALSE}
holt_forecast <- holt(forecast_ts_basic) 
summary(holt_forecast)
```

```{r}
# Use autoplot() to plot the forecasts
autoplot(holt_forecast, predict.size = 1, 
         predict.colour = 'blue', predict.linetype = 'dashed',
         conf.int = TRUE, conf.int.fill = "lightblue") + 
  autolayer(fitted(holt_forecast), series='Predicted') +
  theme_bw()+
  labs(title = "Time Series Forecast - Exponential Smoothing (Holt)",
       subtitle = paste("[World] [Urban] 'At least basic' 2030 ES forecast =",
                       round(holt_forecast$mean[10], 4), "%"),
       x = "YEAR",
       y = "Percentage (%) of Population")+
  guides(colour=guide_legend(title=""))+
  theme(legend.position = "bottom", 
        legend.background = element_rect(fill="lightblue",linetype="solid"),
        plot.subtitle = element_text(color = "deeppink2"))
```

source: https://stackoverflow.com/questions/52997855/add-legend-entry-for-prediction-line-in-rs-forecast-package 


### ARIMA

ARIMA: Auto-Regressive Integrated Moving Average

source: https://www.simplilearn.com/tutorials/data-science-tutorial/time-series-forecasting-in-r#GoTop

```{r}
model_arima <- auto.arima(forecast_ts_basic)
model_arima
```

ARIMA (p, d, q) = https://people.duke.edu/~rnau/411arim.htm   

* p is the number of autoregressive terms,
* d is the number of nonseasonal differences needed for stationarity, and
* q is the number of lagged forecast errors in the prediction equation. 

If it is (0, 1, 1) then it is ES. 

```{r}
#forecast the next 10 years using library(forecast)
model_arima_fc <- forecast(model_arima, level=c(95), h=10)

autoplot(model_arima_fc, predict.size = 1, 
         predict.colour = 'red', predict.linetype = 'dashed',
         conf.int = TRUE, conf.int.fill = "pink", 
         annotations=c("+", "predict"))+
  theme_bw()+
  expand_limits(y=100)+
  labs(title = "Time Series Forecast - ARIMA",
       subtitle = paste("2030 World 'At least basic' ARIMA forecast =",
                       round(model_arima_fc$mean[10], 4), "%"),
       x = "YEAR",
       y = "Median Percentage (%)")
```

##Question

How to resize the display autoplot? Increase font size? 
